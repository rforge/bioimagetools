{
    "contents" : "# Utilities for EBImage\n# \n# Author: fabians\n###############################################################################\n\n#' Labels connected objects in a binary image stack.\n#' @param im a stack of binary images (or a 3d-array)   \n#' @return A Grayscale Image object or an array, containing the labelled version of im.\nbwlabel3d <- function(im){\n\tres <- array(0, dim = dim(im))\n\tdepth <- dim(im)[3]\n\t\n\tlabel <- bwlabel(im[,,1])\n\t#make sure labels are unique for each slice\n\tlabel[label != 0] <- label[label != 0] + 10^(1+floor(log(max(label), 10)))\n\tupdatedLabels <- activeLabels <- unique(as.vector(label[label != 0])) \n\t\n\tcluster <- 1:max(label)\n\tres[,,1] <- label\n\n\tcat(\"labelling.\")\n\t\n\tfor(i in 2:depth){\n\t\tcat(\".\")\n\t\tnewlabel <- bwlabel(im[,,i])\n\t\tnot0 <- newlabel != 0\n\t\t#make sure labels are unique for each slice\n\t\tnewlabel[not0] <- newlabel[not0] + i*10^(1+floor(log(max(newlabel), 10)))\n\t\tdone <- !not0\n\t\talreadyWritten <- !not0\n\t\t\n\t\tif(length(activeLabels)){\n\t\t\tfor(l in activeLabels){\n\t\t\t\t#propagate label 'l' into this slice in stack if there is overlap\n\t\t\t\toverlap <- not0 & label == l\n\t\t\t\tif(any(overlap)){\n\t\t\t\t\t#overwrite all pixels with the same labels as those in the overlap with label 'l'\n\t\t\t\t\toverwrite <- apply(newlabel, 2, \"%in%\", unique(as.vector(newlabel[overlap])))\n\t\t\t\n\t\t\t\t\t# check if pixels in overlap have already been relabeled,\n\t\t\t\t\t# if yes the label to be assigned can be replaced with the previously assigned one \n\t\t\t\t\tif(any(alreadyWritten[overwrite]>0)){\n\t\t\t\t\t\trelabel <- which(res == l, arr.ind=T)\n\t\t\t\t\t\tpreviousLabel <-  unique(res[,,i][overwrite])\n\t\t\t\t\t\t#necessary if overwrite covers area of more than 2 different labels\n\t\t\t\t\t\tpreviousLabel <- previousLabel[previousLabel!=0] \n\t\t\t\t\t\tres[relabel] <- previousLabel\n\t\t\t\t\t\t#remove label 'l' from activeLabels \n\t\t\t\t\t\tupdatedLabels <- updatedLabels[updatedLabels!=l]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres[,,i][overwrite] <- l\n\t\t\t\t\t}\t\n\t\t\t\t\tdone[overwrite] <- TRUE\n\t\t\t\t\t\n\t\t\t\t\talreadyWritten <- alreadyWritten + overwrite\n\t\t\t\t} else {\n\t\t\t\t\t#remove label 'l' from activeLabels if there is no overlap\n\t\t\t\t\tupdatedLabels <- updatedLabels[updatedLabels!=l]\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(any(!done)){\n\t\t\t#add new labels for objects\n\t\t\tupdatedLabels <-c(updatedLabels, unique(as.vector(newlabel[!done])))\n\t\t\tres[,,i][!done] <- newlabel[!done]\n\t\t} \n\t\tactiveLabels <- updatedLabels\n\t\tlabel <- res[,,i] \n\t}\n\t\n\tcat(\", relabelling...\")\n\n\t#re-label with 1 to no. of objects\n\t#changed V.S. 11Sep13\n\tlabels <- sort(unique(as.vector(res)))[-1]\n\tn.labels <- length(labels)\n\tnewlabel<-1\n\t\n\tfor (i in 1:n.labels)\n\t{ \n\t  while (sum(newlabel==labels)>0)newlabel<-newlabel+1\n\t  if (labels[i]>n.labels){\n\t    if(labels%%10==1)cat(\".\")\n\t    res[res==labels[i]]<-newlabel\n\t    labels[i]<-newlabel\n\t  }\n\t}\n\t\n\tcat(\", done.\")\n\t\n\treturn(as.Image(res))\n}\n\n#' Computes moments from image objects\n#' \n#' Computes intensity-weighted centers of objects and their mass (sum of intensities)\n#' \n#' @param mask a labeled stack as returned from bwlabel3d\n#' @param ref the original image stack\n#' @return a matrix with the moments of the objects in the stack\ncmoments3d <- function(mask, ref){\n\tlabels <- 1:max(mask)\n\tret <- t(sapply(labels, function(x){\n\t\t\t\t\t\tind <- which(mask == x, arr.ind=T)\n\t\t\t\t\t\tw <- ref[ind]\n\t\t\t\t\t\treturn(c(x, apply(ind, 2, weighted.mean, w=w), sum(w)))\n\t\t\t\t\t}))\n\tcolnames(ret) <- c(\"label\",\"m.x\",\"m.y\",\"m.z\",\"w\")\n\treturn(ret)\n}\t\n\n\n#' Get central moments of objects in a single-channel image stack\n#' \n#' Uses the methodology used for segmentation in the RBImage vignette \n#'  (threshhold->opening->fillHull) from all 3 spatial directions and \n#'  overlays these results to get a binary image which is then segmented \n#'  with bwlabel3d. Central moments are extracted with cmoments3d \n#' \n#' @param file the path of the image stack\n#' @param threshold  the quantile of intensities used for thresholding if quantile=TRUE \n#' \t\t  or the intensity value if quantile=FALSE, defaults to the 80% quantile\n#' @param threshW, threshH width and height of the moving rectangular window for threshold, defaults to 5.  \n#' @param brushsize the brushsize for makeBrush for opening, defaults to 3 \n#' @param quantile defaults to TRUE\n#' @return a list with the original stack, the labeled stack, and the matrix of central moments of the found objects \npreprocess <- function(file, threshold=.95, threshW = 5,  threshH = 5, brushsize=3, quantile=TRUE){\n\tstopifnot(require(EBImage))\n\t\n\tcat(\"reading file....\")\n\t#read file\n\tim <- readImage(file)\n\t\n\tcat(\"thresholding & smoothing image....\")\n\t#threshold\n#\tif(quantile){\n#\t\tthresh <- quantile(im, threshold)\n#\t\twhile(thresh == 0 &&  threshold < 1){\n#\t\t\tthreshold <- threshold + .01\n#\t\t\tthresh <- quantile(im, threshold)\n#\t\t\tcat(\"\\n cutoff was 0. increasing threshold to \", threshold, \"\\n\")\n#\t\t}\n#\t} else {\n#\t\tthresh <- threshold\n#\t} \n\tif(quantile){\n\t\tthresh <- quantile(im, threshold)\n\t\tstopifnot(thresh != 0)\n\t\tthresh <- quantile(im, threshold)\n\t} else {\n\t\tthresh <- threshold\n\t} \n\t\n\t\n\t\n\timThresh <- thresh(im, threshW, threshH, thresh)\n\t\n\t#smooth binary image from all directions\n\tmask1 <- opening(imThresh, makeBrush(brushsize, shape='disc'))\n\tmask1 <- fillHull(mask1)\n\tmask2 <- opening(aperm(imThresh, c(1,3,2)), makeBrush(brushsize, shape='disc'))\n\tmask2 <- fillHull(mask2)\n\tmask3 <- opening(aperm(imThresh, c(2,3,1)), makeBrush(brushsize, shape='disc'))\n\tmask3 <- fillHull(mask3)\n\tmask <- fillHull(mask1 + aperm(mask2, c(1,3,2)) + aperm(mask3, c(3, 1, 2)))\n\tstopifnot(any(as.logical(mask)))\n\t\n\tcat(\"segmentation....\")\n\t#segmentation\n\tlabel <- bwlabel3d(mask)\n\t\n\tcat(\"get moments\\n\")\n\t#extract moments \n\tmom <- cmoments3d(label, im)\n\t\n\tcat(\"found\", max(label), \"objects in image.\\n\")\n\treturn(list(im=im, \n\t\t\t\tlabel=label, \n\t\t\t\tmoments=mom))\t\n}\n\n\n#' Compute cross-type nearest neighbor distances \n#' @param dist a distance matrix, the upper n1 x n1 part contains distances between objects of type 1\n#' \t\t\tthe lower n2 x n2 part contains distances between objects of type 2\n#' @param n1, n2  numbers of objects of type 1 and 2 respectively\n#' @param w optional weights of the objects (length n1+n2), defaults to equal weights\n#' @return  a (n1+n2) x 2 matrix with the cross-type nearest neighbor distances and \n#' \t\t\tweights given as the sum of the weights of the involved objects\ncrossNN <- function(dist, n1, n2, w = rep(1, n1+n2)){\n\tuse <- dist[-(1:n1),-((n1+1):(n1+n2))] #use only lower left block containing the cross type distances\n\twhereMin <- rbind(\n\t\t\tcbind( n1 + apply(use, 2, which.min), 1:n1), #for each type1 which is closest type2\n\t\t\tcbind((n1+1):(n1+n2), apply(use, 1, which.min))) #for each type2 which is closest type1\n\t\n\tcnn <- dist[whereMin]\n\t\n\t#use sum of weights of the involved objects as weight for the cross-type distance\n\tweights <- apply(whereMin, 1, function(x){\n\t\t\t\tsum(w[x])\n\t\t\t})\n\treturn(cbind(cnn=cnn, w=w))\n}\n\n#' Permutation Test for cross-type nearest neighbor distances\n#' @param dist a distance matrix, the upper n1 x n1 part contains distances between objects of type 1\n#' \t\t\tthe lower n2 x n2 part contains distances between objects of type 2\n#' @param n1, n2  numbers of objects of type 1 and 2 respectively\n#' @param w (optional) weights of the objects (length n1+n2)\n#' @param B number of permutations to generate\n#' @param alternative alternative hypothesis (\"less\" to test H0:Colocalization )\n#' @param returnSample return sampled null distibution\n#' @param papply which apply function to use for generating the null distribution, \n#' \t\tdefaults to mclapply if multicore is available, else lapply\n#' @param ... additional arguments for papply\n#' @return a list with the p.value, the observed weighted mean of the cNN-distances, alternative and (if returnSample) the simulated null dist \ncnnTest <- function(dist, n1, n2, w = rep(1, n1+n2), \n\t\tB = 999, alternative = \"less\", returnSample = TRUE,  \n\t\tpapply = if (require(\"multicore\")) mclapply else lapply, \n\t\t...){\n\t\n\tteststat <- function(dist, n1, n2, w){\n\t\tcnn <- crossNN(dist, n1, n2, w)\n\t\treturn(weighted.mean(x = cnn[,'cnn'], w = cnn[,'w']))\n\t}\n\t\n\tobs <- teststat(dist, n1, n2, w)\n\t\n\tpermutations <- replicate(B, sample(n1+n2), simplify = FALSE)\n\tnulldist <- unlist(papply(permutations, function(x){\n\t\t\t\t\t\tteststat(dist[x, x], n1, n2, w[x])\n\t\t\t\t\t}, ...))\n\tp.value <- switch(alternative, \n\t\t\tgreater = mean(obs < nulldist),\n\t\t\tless  = mean(obs > nulldist),\n\t\t\ttwo.sided = 0.5 * min(mean(obs < nulldist), mean(obs > nulldist)))\n\tret <- list(statistic = \"weighted mean of cNN-distances\", \n\t\t\tp.value = p.value, estimate = obs, alternative = alternative)\n\tret$sample <- nulldist\n\treturn(ret)\n}\n\n\n#' Permutation Test for cross-type nearest neighbor distances\n#' @param im1, im2  image stacks as returned by preprocess\n#' @param hres, vres horizontal and vertical resolution of the stacks\n#' @param B number of permutations to generate\n#' @param alternative alternative hypothesis (\"less\" to test H0:Colocalization )\n#' @param returnSample return sampled null distibution\n#' @param ... additional arguments for papply\n#' @return a list with the p.value, the observed weighted mean of the cNN-distances\ntestColoc <- function(im1, im2, hres = 0.1023810, vres = 0.2500000, B=999, alternative = \"less\", returnSample = TRUE, ...){\n\t#extract centers and adjust to resolution\n\tcenters <- rbind(im1$moments[,c('m.x','m.y','m.z')], im2$moments[,c('m.x','m.y','m.z')])\n\tcenters <- t(t(centers) * c(rep(hres,2),vres))\n\t\n\tn1 <- nrow(im1$moments)\n\tn2 <- nrow(im2$moments)\n\tw <- c(im1$moments[,'w'], im2$moments[,'w'])\n\tdist <- as.matrix(dist(centers)) \n\treturn(cnnTest(dist, n1, n2, w, B, alternative, returnSample, ...))\n}\n\n",
    "created" : 1378903659770.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3497583575",
    "id" : "9D58B742",
    "lastKnownWriteTime" : 1378903720,
    "path" : "~/software/bioimagetools/pkg/bioimagetools2/R/EBImage_Utils.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}